/****   MATHAPI.H    **********  Shabakov D.A.    ***** 31/05/13 ***
*****   MATHAPI.H    **********  Konon V.N.       ***** 20/12/10 ***
*****   MATHAPI.H    **********  Gustinovich N.A. ***** 30/06/06 ***
*****   MATHAPI.H    **********  Kruzhkov A.E.    ***** 04/02/08 ***
*****   MATHAPI.H    **********  Tarakanova I.R.  ***** 14/02/07 ***
*****   MATHAPI.H    **********  Gorbunov A.V.    ***** 04/08/06 ***
*****   MATHAPI.H    **********  Borzov A.U.      ***** 28/03/12 ***
*****   MATHAPI.H    **********  Dishlenko S.G.   ***** 12/09/11 ***
*****   MATHAPI.H    **********  Alexeev S.A.     ***** 11/03/13 ***
*                                                                  *
*              Copyright (c) PANORAMA Group 1991-2013              *
*                     All Rights Reserved                          *
*                                                                  *
********************************************************************
*                                                                  *
*            ОПИСАНИЕ ФУНКЦИЙ ОБРАБОТКИ ДАННЫХ                     *
*        ИНТЕРФЕЙС ДЛЯ ПРОГРАММ НА ЯЗЫКАХ C, PASCAL, BASIC         *
*                                                                  *
*******************************************************************/

#ifndef MATHAPI_H
#define MATHAPI_H
#include <math.h>
#include <stdio.h>
#pragma hdrstop
#ifndef MAPAPI_H
  #include "mapapi.h"
#endif

#ifdef _MAPMATHDLL
  #define _MATHIMP __declspec(dllexport)
#else
  #define _MATHIMP __declspec(dllimport)
#endif

#ifdef LINUXAPI                            // 12/09/11
#define _MATHIMP
#endif

#if defined(_M_X64) || defined(BUILD_DLL64)       // 31/05/13
typedef __int64   HCUT;    // ИДЕНТИФИКАТОР ОБ'ЕКТА
#else
typedef long int  HCUT;    // ИДЕНТИФИКАТОР ОБ'ЕКТА
#endif

 // *********************************************************
 // Схема запуска:
 // =============
 // HCUT hCut = mathCreateCutProcess(hMap, info, precision);
 // if (hCut)
 //    {
 //    while(mathGetNextTriangularObject(hCut, infoNew))
 //         {
 //         ...
 //         }
 //    mathFreeCutProcess(hCut);
 //    }
 // **********************************************************

// Комплексное число  // 07/09/11
typedef struct COMPLEX
{
  double re; // действительная часть
  double im; // мнимая часть
  inline void operator = (const COMPLEX &y) {re = y.re; im = y.im;}
}
  COMPLEX;

// Операции с комплексными числами
inline void operator+=(COMPLEX &x, const COMPLEX &y) {x.re += (double)y.re; x.im += (double)y.im;}
inline void operator-=(COMPLEX &x, const COMPLEX &y) {x.re -= (double)y.re; x.im -= (double)y.im;}
inline void operator*=(COMPLEX &x, const COMPLEX &y) {double temp = x.re; x.re = temp * y.re - x.im * y.im; x.im = temp * y.im + x.im * y.re;}
inline void operator/=(COMPLEX &x, double div)       {x.re /= div; x.im /= div;}

// Умножение комплексных чисел
inline void Complex_mul(COMPLEX *z, const COMPLEX *z1, const COMPLEX *z2)
{
  z->re = z1->re * z2->re - z1->im * z2->im;
  z->im = z1->re * z2->im + z1->im * z2->re;
}

extern "C"
{

// Отсечение элементарного треугольного объекта от сложного площадного бъекта карты
// Создание класса (Конструктор)
// info - площадной бъект карты
// Возвращает указатель на класс
// При ошибке возвращает 0
HCUT WINAPI  mathCreateCutProcess(HMAP Map, HOBJ info, double precision);

// Отсечение элементарного треугольного объекта от сложного площадного бъекта карты
// Запросить следующий треугольный объект
// info - результат (треугольный объект)
// Для заполнения высот точек(если исходный объект имеет 3-х мерную метрику)    // 22/10/04
//     info необходимо создавать с 3-х мерной метрикой
// Возвращает остаток сложного площадного бъекта карты
// При ошибке возвращает 0
HOBJ WINAPI  mathGetNextTriangularObject(HCUT hcut, HOBJ info);

// Отсечение элементарного треугольного объекта от сложного площадного бъекта карты
// Освобождение класса (Деструктор)
long int WINAPI  mathFreeCutProcess(HCUT hcut);


//******************************************************************
//    ФУНКЦИИ ПРЕОБРАЗОВАНИЯ ПЛОЩАДНОГО ОБЪЕКТА С ПОДОБЪЕКТАМИ     *
//    1. В ОДИН КОНТУР                                             *
//    2. ДЕЛЕНИЕ НА ТРЕУГОЛЬНИКИ                                   *
//******************************************************************

// Преобразование объекта  in  и всех его подобъектов в общий контур,
// с сохранением в объект  out
// (объект без подобъектов не обрабатывает)
// При ошибке возвращает 0
long int WINAPI  mathTransformSubjectsToObject(HOBJ in, HOBJ out);  // 04/02/08


// Нарезка контура объекта  in  на отдельные треугольники с размещением
// в объекте  out  в виде составных частей (объекта с подобъектами)
// При ошибке возвращает 0
long int WINAPI  mathCutObjectToTriangles(HOBJ in, HOBJ out);       // 04/02/08


//******************************************************************
//        ФУНКЦИИ РАСЧЁТА ПОЛОЖЕНИЯ ТОЧКИ ДЛЯ НАНЕСЕНИЯ            *
//        НА ВЫБРАННЫЙ ПЛОЩАДНОЙ ОБЪЕКТ                            *
//******************************************************************
//  ИМПОРТИРОВАНИЕ ФУНКЦИЙ :                                       *
//                                                                 *
//  // Загрузка библиотеки                                         *
//  HINSTANCE libInst;                                             *
//                                                                 *
//  // Вызов функции                                               *
//  int (WINAPI *GetObjectCenter)(HMAP hmap, HOBJ info, double *x, *
//                                double *y);                      *
//                                                                 *
//  (FARPROC) GetObjectCenter = mapLoadLibrary("mapmath.dll",      *
//                                          &libInst,              *
//                                          "mathGetObjectCenter");*
//                                                                 *
//  int code = (GetObjectCenter*)(hmap,info,&x,&y);                *
//    ...                                                          *
//                                                                 *
//  // Выгрузка библиотеки                                         *
//  ::FreeLibrary(libInst);                                        *
//                                                                 *
//*****************************************************************/

// Пересечение линии с площадным объектом
long int WINAPI  mathCreateLineCross(HMAP hMap, HOBJ inobj, HOBJ outinfo,
                                          double step);

// Интерполирование линии
long int WINAPI  mathLineInterpolate(HOBJ inobj, HOBJ outobj,
                                          double step);

// Запросить центр площадного объекта
long int WINAPI  mathGetObjectCenter(HMAP hmap, HOBJ info,
                                          double *x,double *y);

// Установить заданную длину отрезка между точками с исходными      //11/03/13
// координатами x1,y1 и x2,y2
// delta  - новое расстояние
// number - номер редактируемой точки (1- изменяются x1 и y1, 2- x2 и y2)
// При ошибке возвращает 0

long int WINAPI  mathSetLineLength(double *x1,double *y1,double *x2,double *y2,
                                       double delta,long int number);

// Создание списка номенклатур по заданным габаритам района
// hmap - идентификатор открытых данных
// info  - заданная область расчёта номенклатур листов карты (метрика
//                                              должна быть замкнутой)
// scale - знаменатель масштаба карты (25000 - 1000000)
// listreg - адрес массива структур паспортных данных листа карты
// sheet - максимальное число номенклатур
// Возвращаемое значение: при ошибке - 0,
// при нормальном завершении заполнятся поля структуры LISTREGISTER для
// каждого листа
long int WINAPI  mathSheetFromFrame(HMAP  hmap,
                                  HOBJ info, long scale,
                                  LISTREGISTER* listreg,
                                  long sheet);

// Установить имя листа
// b,l    - координаты расчёта
// comp - признак сомпановки (сдвоенные, ...)
// name - номенклатура
// При ошибке возвращает 0
long int WINAPI mathSetSheetName(long scale, double b, double l, int comp, char* name);

// Контроль габаритов района создания номенклатур
// info  - заданная область построения листов карты
// выходные параметры:
// frame - координаты 2-х углов области построения листа
// regim - параметр учёта прохождения через осевой меридиан
//                    (0 - осевой меридиан не пересекается
//                     1 - осевой меридиан пересекается)
// При ошибке возвращает 0
long int WINAPI  mathCheckFrame(HMAP hmap, HOBJ info, FRAME*frame,
                                         int &regim);

// Заполнение полей массива структур LISTREGISTER паспортных данных
// array - адрес списка номенклатур,рассчитанных по заданной области
// listreg - адрес массива структур паспортных данных листа карты
// scale   - знаменатель масштаба (25000 - 1000000)
// countname - число рассчитанных номенклатур
// При ошибке возвращает 0
long int WINAPI  mathSetListRegister(char* array,
                                              LISTREGISTER*listreg,
                                              long scale, long countname);

// Отбраковка номенклатур,не принадлежащих заданной области
// info  - заданная область построения листов карты
// listreg - адрес массива структур паспортных данных листа карты
// count   - число рассчитанных номенклатур после отбраковки
// При ошибке возвращает 0, иначе  число номенклатур после отбраковки
long int WINAPI  mathSetBelongNomenclature(HMAP hmap, HOBJ info,
                                                    LISTREGISTER*listreg,
                                                    long count);


// Определить номенклатуру листа по масштабу scale и геодезическим координатам
// центра b,l (в градусах)
// name - номенклатура листа
// comp - признак компановки(создавать сдвоенные листы - 1
//                           не создавать              - 0)
// При ошибке возвращает 0, иначе 1

long int WINAPI  mathGetRuleSheetName(long int scale,double b,double l,
                                               char *name,long int comp);


//******************************************************************
//
//                   ФУНКЦИИ ГЕНЕРАЛИЗАЦИИ
//
//  Перенос объектов с вытягиванием на рамку
//  Сшивка объектов вдоль линии сводки
//  Генерализация изолиний рельефа
//
//******************************************************************

// Перенос объектов с одной карты на другую (большего масштаба) с вытягиванием на рамку
//
// handle    - диалог визуального сопровождения процесса обработки.
// mapin     - исходная карта
// numberin  - номер листа, на котором расположен объект
// mapout    - выходная карта
// numberout - номер листа, на который переносится объект
//
// Диалогу визуального сопровождения процесса обработки посылаются сообщения:
//   -  (WM_PROGRESSBAR) Извещение об изменении состояния процесса
//      WPARAM - текущее состояние процесса в процентах (0% - 100%)
//      Если функция-отклик возвращает WM_PROGRESSBAR, то процесс завершается.
// При ошибке возвращает 0

long int WINAPI mathObjectCopying(HWND handle, HMAP mapin,  long int numberin,
                                          HMAP mapout, long int numberout);   // 21/06/06

// Сшивка объектов вдоль линии сводки
//
// handle  - диалог визуального сопровождения процесса обработки.
// map     - исходная карта
// number  - номер листа карты
// delta   - допуск при дотягивании (в метрах)
//
// Диалогу визуального сопровождения процесса обработки посылаются сообщения:
//   -  (WM_PROGRESSBAR) Извещение об изменении состояния процесса
//      WPARAM - текущее состояние процесса в процентах (0% - 100%)
//      Если функция-отклик возвращает WM_PROGRESSBAR, то процесс завершается.
// При ошибке возвращает 0

long int WINAPI mathObjectJoining(HWND handle, HMAP map,
                                          long int number, double delta);   // 21/06/06


//******************************************************************
// Генерализация опорных пунктов (округление, огрубление)
//******************************************************************

typedef struct ROUGH
{
  double    Precision;         // Точность
  double    Scatter;           // Разброс
  long int  PrecisionFlag;     // Флаг выполнения округления по точности
  long int  ScatterFlag;       // Флаг выполнения разброса
}
  ROUGH;

// Генерализация опорных пунктов (округление, огрубление)
// map     - исходная карта
// keyfile - имя INI-файла
// handle  - диалог визуального сопровождения процесса обработки.

long int WINAPI mathDissemble(HMAP map, char* keyfile, ROUGH* rough, HWND handle);


//******************************************************************
//                ГЕНЕРАЛИЗАЦИЯ ИЗОЛИНИЙ РЕЛЬЕФА
//******************************************************************

// Сообщение о проценте выполненных работ
#define IDC_PERCENT_ISOLINE  0x3000

// Генерализация изолиний рельефа

long int WINAPI mathIsolineGeneralization(HMAP hmap,
                                                  const char* txtname,
                                                  HWND handle);

//******************************************************************
//                ГЕНЕРАЛИЗАЦИЯ ПЛОЩАДНЫХ РЕК
//******************************************************************

// Сообщение о проценте выполненных работ
#define IDC_PERCENT_SQRIVER  0x3001

typedef struct GEN_SQUARERIVER                           // 11/11/06
{
  HMAP      Map;            // Открытая карта
  HSELECT   Select;         // Обрабатываемые объекты - притоки
  HWND      Handle;         // Идентификатор окна для посылки сообщений
  long int  DiapasonCount;  // Число диапазонов

  double    MinWidth;       // Допустимая ширина преобразования (единицы ???)
  double    Precision;      // Допуск определения близлежащих объектов гидрографии

  char      OldKey[32];     // Ключ преобразуемого объекта

  HSELECT   SelectAdjust;   // Cогласуемые объекты
  char      Reserve[28];    // Резерв
}
  GEN_SQUARERIVER;

typedef struct GEN_SQUARERIVER_DIAPASON                  // 11/11/06
{
  long int Width1;          // Минимальная ширина диапазона в метрах на местности
  long int Width2;          // Максимальная ширина диапазона в метрах на местности
  char NewKey[32];          // Ключ получаемого (нового) объекта
}
  GEN_SQUARERIVER_DIAPASON;

// Генерализация площадной реки с учетом диапазонов ее ширины
// (ключ нового объекта назначается в соответствии с максимальной
//  шириной в метрах на местности преобразуемого участка исходного
//  площадного объекта)
// parm      - общие параметры функции
// diapasons - массив параметров диапазонов
                                                        // 11/11/06
long int WINAPI genSquareRivers(GEN_SQUARERIVER* parm,
                                        GEN_SQUARERIVER_DIAPASON* diapasons);

// Устаревшая структура
typedef struct RIVERGENERALIZATION
{
 char OldKey [32];
 char NewKey [32];
 double Width;
 double Precision;
}
  RIVERGENERALIZATION;

// Генерализация площадной реки без учета диапазонов ее ширины
// (устаревшая функция)
long int WINAPI mathRiverGeneralization(HMAP hmap,
                                                HSELECT select,
                                                RIVERGENERALIZATION* parm);

//******************************************************************
// РЕШЕНИЕ СИСТЕМЫ НОРМАЛЬНЫХ УРАВНЕНИЙ                           // 28/05/10
//******************************************************************

#if defined(_M_X64) || defined(BUILD_DLL64)       // 31/05/13
typedef __int64  HEQUATIONS; // ИДЕНТИФИКАТОР СИСТЕМЫ НОРМАЛЬНЫХ УРАВНЕНИЙ (УКАЗАТЕЛЬ НА TEquations)
#else
typedef long int HEQUATIONS; // ИДЕНТИФИКАТОР СИСТЕМЫ НОРМАЛЬНЫХ УРАВНЕНИЙ (УКАЗАТЕЛЬ НА TEquations)
#endif

// Создание системы нормальных уравнений
// size  - количество неизвестных
// isMHK - 1 - количество уравнений больше количества неизвестных
//         0 - количество уравнений равно количеству неизвестных
// Возвращает идентификатор системы уравнений
// Для каждого полученного и больше не используемого
// идентификатора необходим вызов функции mapFreeEquations()
// При ошибке возвращает ноль
_MATHIMP HEQUATIONS WINAPI mapCreateEquations(long int size, long int isMHK);

// Освобождение идентификатора системы нормальных уравнений
// hequations - идентификатор системы уравнений
_MATHIMP void WINAPI mapFreeEquations(HEQUATIONS hequations);

// Добавление уравнения в систему нормальных уравнений
// hequations - идентификатор системы уравнений
// equation   - коэффициенты уравнения
//              длина = size + 1 (коэффициенты уравнения + остаток)
// При ошибке возвращает ноль
_MATHIMP long int WINAPI mapAddEquation(HEQUATIONS hequations, double *equation);

// Решение системы уравнений
// Перед вызовом система должна быть заполнена mapAddEquation
// hequations - идентификатор системы уравнений
// При ошибке возвращает ноль
_MATHIMP long int WINAPI mapSolve(HEQUATIONS hequations);

// Возвращает результат решения системы нормальных уравнений
// Перед вызовом система должна быть решена mapSolve
// hequations - идентификатор системы уравнений
// num        - номер неизвестного (от 0 до size - 1)
// value      - возвращаемое значение
// При ошибке возвращает ноль
_MATHIMP long int WINAPI mapGetResult(HEQUATIONS hequations, long int num, double *value);

//******************************************************************
// ЛИНЕЙНОЕ ТРАНСФОРМИРОВАНИЕ ПРЯМОУГОЛЬНЫХ КООРДИНАТ
//******************************************************************

// Тип линейного трансформирования
enum LINEARTRANSFTYPE
{
   LT_OFFSET            = 0, // Сдвиг
   LT_OFFSETROTATE      = 1, // Сдвиг, поворот
   LT_OFFSETROTATESCALE = 2, // Сдвиг, поворот, масштаб
   LT_AFFINE            = 3, // Аффинное трансформирование
};

// Параметры линейного трансформирования
typedef struct LINEARTRANSFPARM
{
  double a, b, c, d, e, f; // из исходной в выходную X = a + bx + cy; Y = d + ex + fy
  double A, B, C, D, E, F; // из выходной в исходную x = A + BX + CY; y = D + EX + FY
  double Scale, Rotate;    // коэффициент масштабирования (= расстояние в вых.СК / расстояние в исх.СК)
                           // и угол поворота в радианах
                           // (при аффинном - средний масштаб и поворот, т.к. при аффинном
                           // они разные для Х и Y)
}
  LINEARTRANSFPARM;

#if defined(_M_X64) || defined(BUILD_DLL64)       // 31/05/13
typedef __int64 HTRANSF;  // ИДЕНТИФИКАТОР ЛИНЕЙНОГО ТРАНСФОРМИРОВАНИЯ КООРДИНАТ
#else
typedef long int HTRANSF; // ИДЕНТИФИКАТОР ЛИНЕЙНОГО ТРАНСФОРМИРОВАНИЯ КООРДИНАТ
#endif

// Создание класса трансформирования координат
// count - количество точек для расчета параметров трансформирования
//   В зависимости от типа трансформирования:
//    LT_OFFSET                             - минимальное количество точек = 1
//    LT_OFFSETROTATE, LT_OFFSETROTATESCALE - минимальное количество точек = 2
//    LT_AFFINE                             - минимальное количество точек = 3
// pointsin   - координаты точек в исходной системе координат
// pointsout  - координаты точек в выходной системе координат
// transftype - тип линейного трансформирования
//   LT_OFFSET - преобразование сдвиг
//       X = x0 + x
//       Y = y0 + y
//   LT_OFFSETROTATE - преобразование сдвиг, поворот
//       X = x0 + x * cos - y * sin
//       Y = y0 + x * sin + y * cos
//   LT_OFFSETROTATESCALE - преобразование масштаб, сдвиг, поворот
//       X = x0 + x * cos * m - y * sin * m
//       Y = y0 + x * sin * m + y * cos * m
//   LT_AFFINE - аффинное трансформирование (полином 1 степени)
//       X = a + x * b + y * c
//       Y = d + x * e + y * f
// Возвращает идентификатор класса трансформирования координат
// Для каждого полученного и больше не используемого идентификатора
// необходим вызов функции mapFreeTransform()
// При ошибке возвращает ноль
_MATHIMP HTRANSF WINAPI mapCreateTransform(long int count, DOUBLEPOINT *pointsin,
                                           DOUBLEPOINT *pointsout, LINEARTRANSFTYPE transftype);

// Освобождение класса трансформирования координат
// htransf - идентификатор класса трансформирования координат
_MATHIMP void WINAPI mapFreeTransform(HTRANSF htransf);

// Трансформирование координат из исходной системы координат в выходную
// htransf  - идентификатор класса трансформирования координат
// xin, yin   - координаты в исходной системе координат
// xout, yout - вычисленные координаты в выходной системе координат
// При ошибке возвращает ноль
_MATHIMP long int WINAPI mapTransformIn2Out(HTRANSF htransf, double xin, double yin,
                                             double *xout, double *yout);

// Трансформирование координат из выходной системы координат в исходную
// htransf  - идентификатор класса трансформирования координат
// xout, yout - координаты в выходной системе координат
// xin, yin   - вычисленные координаты в исходной системе координат
// При ошибке возвращает ноль
_MATHIMP long int WINAPI mapTransformOut2In(HTRANSF htransf, double xout, double yout,
                                           double *xin,  double *yin);

// Возвращает вычисленные параметры траснформирования
// htransf  - идентификатор класса трансформирования координат
// При ошибке возвращает ноль
_MATHIMP long int WINAPI mapGetTransformParam(HTRANSF htransf, LINEARTRANSFPARM *parm); //07/10/10

//******************************************************************
// НЕЛИНЕЙНОЕ ТРАНСФОРМИРОВАНИЕ ПРЯМОУГОЛЬНЫХ КООРДИНАТ
//******************************************************************

// Тип нелинейного трансформирования
enum NONLINEARTRANSFTYPE                                          // 06/09/10
{
   NT_LINEARSHEET    = 0,     // Линейный резиновый лист
   NT_NONLINEARSHEET = 1,     // Нелинейный резиновый лист
   NT_POLYNOM4       = 4,     // Полином 4  коэффициента
   NT_POLYNOM5       = 5,     // Полином 5  коэффициентов
   NT_POLYNOM6       = 6,     // Полином 6  коэффициентов
   NT_POLYNOM7       = 7,     // Полином 7  коэффициентов
   NT_POLYNOM8       = 8,     // Полином 8  коэффициентов
   NT_POLYNOM9       = 9,     // Полином 9  коэффициентов
   NT_POLYNOM10      = 10,    // Полином 10 коэффициентов
   NT_POLYNOM11      = 11,    // Полином 11 коэффициентов
   NT_POLYNOM12      = 12,    // Полином 12 коэффициентов
   NT_POLYNOM13      = 13,    // Полином 13 коэффициентов
   NT_POLYNOM14      = 14,    // Полином 14 коэффициентов
   NT_POLYNOM15      = 15,    // Полином 15 коэффициентов
   NT_POLYNOM16      = 16,    // Полином 16 коэффициентов
   NT_POLYNOM17      = 17,    // Полином 17 коэффициентов
   NT_POLYNOM18      = 18,    // Полином 18 коэффициентов
   NT_POLYNOM19      = 19,    // Полином 19 коэффициентов
   NT_POLYNOM20      = 20,    // Полином 20 коэффициентов
   NT_POLYNOM21      = 21,    // Полином 21 коэффициентов
   NT_POLYNOMRANK2   = NT_POLYNOM6,  // Полином 2 степени
   NT_POLYNOMRANK3   = NT_POLYNOM10, // Полином 3 степени
   NT_POLYNOMRANK4   = NT_POLYNOM15, // Полином 4 степени
   NT_POLYNOMRANK5   = NT_POLYNOM21, // Полином 5 степени
};

#if defined(_M_X64) || defined(BUILD_DLL64)       // 31/05/13
typedef __int64  HNONLINETRANSF; // ИДЕНТИФИКАТОР НЕЛИНЕЙНОГО ТРАНСФОРМИРОВАНИЯ КООРДИНАТ
#else
typedef long int HNONLINETRANSF; // ИДЕНТИФИКАТОР НЕЛИНЕЙНОГО ТРАНСФОРМИРОВАНИЯ КООРДИНАТ
#endif

// Создание класса нелинейного трансформирования координат
// count     - количество точек для расчета параметров трансформирования
//   В зависимости от типа трансформирования:
//   NT_LINEARSHEET, NT_NONLINEARSHEET - минимальное количество точек = 3
//   NT_POLYNOM                        - минимальное количество точек = количеству коэффициентов
//   NT_POLYNOMRANK2                   - минимальное количество точек = 6
//   NT_POLYNOMRANK3                   - минимальное количество точек = 10
//   NT_POLYNOMRANK4                   - минимальное количество точек = 15
//   NT_POLYNOMRANK5                   - минимальное количество точек = 21
// pointsin  - координаты точек в исходной системе координат
// pointsout - координаты точек в выходной системе координат
// interestframe - область интереса, т.е. прямоугольник, ограничивающий область
//   применения функции mapNonlineTransformIn2Out.
//   Если = 0, то экстраполяция искажений вне области расположения опорных точек
//   не выполняется, в этом случае virtualpointcount должно быть равно 0
// virtualpointcount - количество виртуальных точек, добавляемых по границе
//   области интереса. Минимальное количество = 4. Если interestframe = 0, то
//   virtualpointcount должно быть равно 0.
// transftype - тип нелинейного трансформирования см. NONLINEARTRANSFTYPE
// Возвращает идентификатор класса нелинейного трансформирования координат
// Для каждого полученного и больше не используемого идентификатора
// необходим вызов функции mapFreeNonlineTransform()
// При ошибке возвращает ноль
_MATHIMP HNONLINETRANSF WINAPI mapCreateNonlineTransform(long int count, DOUBLEPOINT *pointsin, DOUBLEPOINT *pointsout,
                                                        DFRAME *interestframe, long int virtualpointcount,
                                                        NONLINEARTRANSFTYPE transftype);

// Освобождение класса нелинейного трансформирования координат
// htransf - идентификатор класса трансформирования координат
_MATHIMP void WINAPI mapFreeNonlineTransform(HNONLINETRANSF htransf);

// Нелинейное трансформирование координат из исходной системы координат в выходную
// htransf  - идентификатор класса трансформирования координат
// xin, yin   - координаты в исходной системе координат
// xout, yout - вычисленные координаты в выходной системе координат
// При ошибке возвращает ноль
_MATHIMP long int WINAPI mapNonlineTransformIn2Out(HNONLINETRANSF htransf, double xin, double yin,
                                                   double *xout, double *yout);

// Возвращает координаты виртуальных точек               07/12/10
// Возвращает количество виртуальных точек, если возвращает 0, то виртуальных точек нет
// В virtualpointsin возвращается указатель на массив виртуальных точек в исходной СК
// В virtualpointsout возвращается указатель на массив виртуальных точек в выходной СК
_MATHIMP long int WINAPI mapNonlineTransformGetVirtualPoints(HNONLINETRANSF htransf,
                                                             const DOUBLEPOINT **virtualpointsin,
                                                             const DOUBLEPOINT **virtualpointsout);

// Вычисление датума                                     26/04/11
// pointcount - количество точек
// points     - геодезические координаты точек на эллипсоиде ellipsoid
//              b, l, h - широта (радианы), долгота (радианы), эллипсоидальная высота (метры)
// wgspoints  - геодезические координаты точек на WGS84
//              b, l, h - широта (радианы), долгота (радианы), эллипсоидальная высота (метры)
// ellipsoid  - эллипсоид, для которого вычисляется датум
// datum      - вычисленный датум
// При ошибке возвращает 0
_MATHIMP long int WINAPI mapCalculateDatum(long int pointcount, XYHDOUBLE *points, XYHDOUBLE *wgspoints,
                                           ELLIPSOIDPARAM *ellipsoid, DATUMPARAM *datum);

// Вычисление датума                                                   28/03/12
// iscalcoffset - признак вычисления линейных коэффициентов смещения
// iscalcrotate - признак вычисления угловых коэффициентов вращения
// iscalcscale  - признак вычисления масштабного коэффициента
// pointcount   - количество точек
// points       - геодезические координаты точек на эллипсоиде ellipsoid
//                b, l, h - широта (радианы), долгота (радианы), эллипсоидальная высота (метры)
// wgspoints    - геодезические координаты точек на WGS84
//                b, l, h - широта (радианы), долгота (радианы), эллипсоидальная высота (метры)
// ellipsoid    - эллипсоид СК, для которой вычисляется датум
// datum        - вычисленный датум
// При ошибке возвращает 0
_MATHIMP long int WINAPI mapCalculateDatumEx(long int iscalcoffset, long int iscalcrotate, long int iscalcscale,
                                             long int pointcount, XYHDOUBLE *points, XYHDOUBLE *wgspoints,
                                             ELLIPSOIDPARAM *ellipsoid, DATUMPARAM *datum);

// Параметры вызова задачи вычисления параметров проекции Transverse Mercator  // 12/07/11
typedef struct CALCTRANSMERCATORPARM
{
  int    IsCalcM;  // нужно ли вычислять масштаб (если нет, то M должен быть установлен)
  int    IsSetM;   // установлено ли приблизительное значение масштаба (используется если надо вычислять)
  double M;        // на входе - приблизительный масштаб, на выходе вычисленный
  int    IsCalcLo; // нужно ли вычислять долготу осевого меридиана (если нет, то L0 должен быть установлен)
  int    IsSetLo;  // установлено ли приблизительное значение долготы осевого меридиана (используется если надо вычислять)
  double Lo;       // на входе - приблизительная долгота осевого меридиана, на выходе вычисленная
  int    IsCalcBo; // нужно ли вычислять широту точки отсчета (если нет, то В0 должен быть установлен)
  int    IsSetBo;  // установлено ли приблизительное значение широты точки отсчета (используется если надо вычислять)
  double Bo;       // на входе - приблизительная широта точки отсчета, на выходе вычисленная
  int    IsCalcDx; // нужно ли вычислять сдвиг по Х (если нет, то Dx должен быть установлен)
  int    IsSetDx;  // установлено ли приблизительное значение сдвига по Х (используется если надо вычислять)
  double Dx;       // на входе - приблизительное значение сдвига по Х, на выходе вычисленное
  int    IsCalcDy; // нужно ли вычислять сдвиг по Y (если нет, то Dy должен быть установлен)
  int    IsSetDy;  // установлено ли приблизительное значение сдвига по Y (используется если надо вычислять)
  double Dy;       // на входе - приблизительное значение сдвига по Y, на выходе вычисленное
  int    IsCalcAn; // нужно ли вычислять угол поворота МСК(если нет, то An должен быть установлен)
  int    IsSetAn;  // установлено ли приблизительное значение угла поворота МСК (используется если надо вычислять)
  double An;       // на входе - приблизительное значение угла поворота МСК, на выходе вычисленное
}
  CALCTRANSMERCATORPARM;

// Вычисление параметров местной системы координат по набору точек             // 12/07/11
// (проекция Transverse Mercator + поворот)
// вычисляются : - масштаб на осевом меридиане
//               - долгота осевого меридиана
//               - широта точки отсчета
//               - поправка по Х
//               - поправка по Y
//               - угол поворота местной системы координат
// pointcount - количество точек
// points     - геодезические координаты точек
//              b, l - широта (радианы), долгота (радианы)
// points     - прямоугольные координаты точек в местной системе координат
//              система координат левая, координаты в метрах
// ellipsoid  - используемый эллипсоид
// parm       - вычисляемые параметры проекции (см. mathapi.h)
// При ошибке возвращает 0
_MATHIMP long int WINAPI mapCalculateTransverseMercatorParam(long int pointcount, DOUBLEPOINT *blpoints,
                                                             DOUBLEPOINT *xypoints, ELLIPSOIDPARAM *ellipsoid,
                                                             CALCTRANSMERCATORPARM *parm);

//---------------------------------------------------------------------------
// Преобразование Фурье (дискретное быстрое + модификация для произвольного count)   // 07/09/11
//---------------------------------------------------------------------------
// x - массив комплексных чисел
//   Для прямого преобразования Фурье
//   - на входе  - массив измерений
//                Обычно измерения являются действительными числами, в этом случае
//                значение измерения заносится в x.re, в x.im заносится 0
//   - на выходе - массив гармоник (комплексное число)
//     Частота гармоники V = i / T, где i - номер гармоники (от 1, в 0 среднее значение * count)
//                                      T - СУММАРНОЕ время измерения
//     Амплитуда гармоники A = sqrt(x[i].re^2 + x[i].im^2) / count
//     Фаза гармоники      F = atan2(x[i].im, x[i].re)
//   Для обратного преобразования Фурье
//   - на входе  - массив гармоник (комплексное число)
//                Обычно измерения являются действительными числами, в этом случае
//                значение измерения заносится в x.re, в x.im заносится 0
//   - на выходе - массив измерений (брать действительную часть)
// count - размер массива x
// isdirect = 1 - прямое преобразование Фурье
//          = 0 - обратное преобразование Фурье
// График спектра симметричен относительно центра графика, поэтому обычно
// график рисуют для 1 <= i < count / 2, в этом случае амплитуду умножают на 2
// При ошибке возвращает 0
//---------------------------------------------------------------------------
_MATHIMP long int WINAPI mapFourierTransform(COMPLEX *x, long int count, long int isdirect);


}       // extern "C"

#endif  // MATHAPI_H
