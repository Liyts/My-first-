/****** MAPLUA.H *************** Belenkov O.V.  ******* 29/03/13 ***
******* MAPLUA.H *************** Kruzhkov A.E.  ******* 19/04/16 ***
*                                                                  *
*              Copyright (c) PANORAMA Group 1991-2016              *
*                      All Rights Reserved                         *
*                                                                  *
********************************************************************
*                                                                  *
*                      For Windows & Linux                         *
*                                                                  *
********************************************************************
*                                                                  *
*          API-ИНТЕРФЕЙС ДЛЯ ВЫЗОВА ИНТЕРПРЕТАТОРА LUA             *
*                                                                  *
*******************************************************************/

#ifndef MAPLUA_H
#define MAPLUA_H

#ifndef MAPTYPE_H
  #include "maptype.h"
#endif

#ifdef LINUXAPI                            // 19/04/16
  #define _LUAAPI
  #define _LUAIMP
#else
  #define _LUAAPI  WINAPI
  #if defined(LUA_DLL)
    #define _LUAIMP __declspec(dllexport)
  #else
    #define _LUAIMP __declspec(dllimport)
  #endif
#endif


// При написании скрипта могут быть использованы следующие
// предопределенные имена функций:

// addCodeSem(код_семантики, значение) - добавить новое значение семантики для кода
// delCodeSem(код_семантики) - удалить семантику для кода
// delSem(номер_семантики) - удалить семантику по номеру
// getCode() - запросить классификационный код объекта на карте
// getIdent() - запросить уникальный номер объекта на карте
// getLayerName() - запросить название слоя объекта
// getLength()    - запросить длину/периметр объекта
// getLocal() - запросить локализацию объекта (0-линия,1-полигон,2-точка,3-подпись,4-вектор,5-комбинированная подпись-шаблон)
// getName()      - запросить название объекта
// getCodeSem(код_семантики, значение_при_отсутствии) - запросить числовое значение семантики по коду
// getCodeSemStr(код_семантики, значение_при_отсутствии) - запросить строковое значение семантики по коду
// getSem(номер_семантики, значение_при_отсутствии) - запросить числовое значение семантики по номеру с 1
// getSemStr(номер_семантики, значение_при_отсутствии) - запросить строковое значение семантики по номеру с 1
// getSemCount() - запросить число семантик у объекта
// getSemCode(номер_семантики) - запросить код семантики объекта по номеру с 1
// getSheetName() - запросить название листа карты, где расположен объект
// getSquare() - запросить площадь объекта
// getSubjectCount() - запросить число подобъектов, включая основной объект
// getText(номер_подобъекта) - запросить текст подписи по номеру подобъекта с 0
// setCodeSem(код_семантики, значение) - установить числовое или символьное значение семантики по коду
// setCodeAndLocal(код_объекта,локализация) - установить новый код (условный знак) объекту
// setSem(номер_семантики, значение) - установить числовое или символьное значение семантики по номеру с 1
// setText(номер_подобъекта) - установить текст подписи

/*

---------------------------------------------------------------------
-- Простые примеры (в одном скрипте может вычисляться произвольное число значений):
-- Умножить площадь объекта на относительную высоту из семантики с кодом 1 и
-- запомнить значение объема в семантике с кодом 10 (коды зависят от классификатора карты)
---------------------------------------------------------------------

value = getSquare() * getCodeSem(1)
setCodeSem(10, value)

-- Если значение семантики с кодом 11 установлено, то
-- умножить длину объекта на ширину из семантики с кодом 11 и
-- запомнить значение площади в семантике с кодом 12 (коды зависят от классификатора карты),
-- например, для определения площади покрытия дороги (линейный объект)

if getCodeSem(11, -1) ~= -1 then
  value = getLength() * getCodeSem(11)
  setCodeSem(12, value)
end

-- Сформировать строку из семантики 9 и имени слоя и записать
-- в семантику 345. Если семантики 9 нет, то записать вместо нее "No name"

value = getCodeSemStr(9, "No name").." - "..getLayerName()
setCodeSem(345, value);

---------------------------------------------------------------------
-- Пример скрипта для сбора статистики по выделенным объектам карты и
-- вывода отчета в текстовый файл
-- Включает три функции с обязательными именами Start(), DoObject() и Stop()
-- Функции Start() и Stop()нужны для подготовки переменных и сохранения
-- результата расчетов
-- Функция DoObject() вызывается на каждый объект
-- Если функции Start() или DoObject() нет в скрипте, то весь текст
-- скрипта считается выполняемой функцией, как в предыдущем примере
-- Функция Stop() может присутствовать в любом случае и вызывается 
-- после обработки всех выделенных объектов, если она есть в скрипте
---------------------------------------------------------------------

-- Функция Start() вызывается при открытии скрипта для инициализации
-- глобальных переменных
function Start()
 TypeA = 0
 TypeB = 0
 TypeC = 0
 Total = 0;
 File  = io.open("c:\\Report.txt", "w")
end

-- Функция Stop() вызывается перед закрытием скрипта для обобщения результата
-- и формирование отчета

function Stop()
 s = "Число обработанных объектов равно "..Total.."\n\r"
 File:write(s)
 p = 100 * TypeA / Total
 s = "Число объектов типа А равно "..TypeA.."\t процент равен "..p.."\n\r"
 File:write(s)
 p = 100 * TypeB / Total
 s = "Число объектов типа B равно "..TypeB.."\t процент равен "..p.."\n\r"
 File:write(s)
 p = 100 * TypeC / Total
 s = "Число объектов типа C равно "..TypeC.."\t процент равен "..p.."\n\r"
 File:write(s)

 io.close(File)
end

-- Сбор статистики выполняется в основной части скрипта в функции DoObject(),
-- если задана функция Start() для инициализации
function DoObject()
 if getCodeSem(4) < 100 then TypeA = TypeA + 1;
  elseif getCodeSem(4) < 200 then TypeB = TypeB + 1;
   else TypeC = TypeC + 1; end
 Total = Total + 1
end

---------------------------------------------------------------------
-- Пример скрипта для обновления текстовой семантики и текста подписи
---------------------------------------------------------------------

-- Запросить семантику с кодом 9 "Собственное название"
sem = getCodeSemStr(9, -1)
if sem ~= -1
then
-- Заменить строку "лет." на "летник"
if string.find(sem, "лет.") and string.len(sem) == 4 then
setCodeSem(9, "летник")
end
end

-- Это подпись?
if getLocal() ~= 3 then
return;
end

text = getText(0);

-- Заменить строку "лет." на "летник"
if string.find(text, "лет.") and string.len(text) == 4 then
setText(0, "летник")
end

*/

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++ ОПИСАНИЕ ФУНКЦИЙ ДОСТУПА К ИНТЕРПРЕТАТОРУ LUA +++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++

#define HLUA HANDLE

extern "C"
{

 // Открыть скрипт для многократного выполнения
 // Возвращает идентификатор открытого скрипта на языке Lua
 // После завершения работы скрипт необходимо закрыть в luaCloseScript
 // script - указатель на строку, содержащую скрипт на языке Lua для выполнения
 // При ошибке возвращает ноль

_LUAIMP HLUA _LUAAPI luaOpenScript(const char * script);

 // Закрыть скрипт
 // hlua  - идентификатор открытого скрипта на языке Lua

_LUAIMP void _LUAAPI luaCloseScript(HLUA hlua);

 // Выполнить сценарий
 // hlua  - идентификатор открытого скрипта на языке Lua
 // hObj  - идентификатор обрабатываемого объекта
 // error - код ошибки при выполнении скрипт (IDS_PARM, IDS_MEMORY, IDS_DOERROR)
 // При ошибке возвращает ноль

_LUAIMP long int _LUAAPI luaDoScript(HLUA hlua, HOBJ hObj, long int * error);

 // Завершить сценарий
 // Вызывается после завершения многократного вызова luaDoScript
 // для обработки результатов
 // При ошибке возвращает ноль

_LUAIMP long int _LUAAPI luaStopScript(HLUA hlua);

 // Запросить результат выполнения скрипта в виде числа
 // Для получения результата выполнения скрипта в конце
 // скрипта должен быть оператор "return"
 // hlua  - идентификатор открытого скрипта на языке Lua
 // value - указатель на переменную, в которую будет записан результат
 // При ошибке возвращает ноль

_LUAIMP long int _LUAAPI luaGetDoubleResult(HLUA hlua, double * value);

 // Запросить результат выполнения скрипта в виде числа
 // Для получения результата выполнения скрипта в конце
 // скрипта должен быть оператор "return"
 // hlua  - идентификатор открытого скрипта на языке Lua
 // value - указатель на буфер, в которую будет записана строка
 // size  - размер выделенного буфера
 // При ошибке возвращает ноль

_LUAIMP long int _LUAAPI luaGetStringResult(HLUA hlua, char * value, int size);

 // Выполнить однократно скрипт для заданного объекта
 // Для получения результата выполнения скрипта в конце
 // скрипта должен быть оператор "return"
 // hObj   - идентификатор обрабатываемого объекта
 // script - указатель на строку, содержащую скрипт на языке Lua для выполнения
 // error  - код ошибки при выполнении скрипт (IDS_PARM, IDS_MEMORY, IDS_DOERROR)
 // При ошибке возвращает ноль

_LUAIMP double _LUAAPI luaDoShortScript(HOBJ hObj, const char * script, long int * error);

 // Вызвать диалог для ввода и выполнения скриптов на языке Lua
 // hmap  - идентификатор открытой карты
 // parm  - указатель на параметры задачи (поле Handle должно содержать
 //         идентификатор главного окна)
 // При ошибке возвращает ноль

_LUAIMP long int _LUAAPI luaScriptDialog(HMAP hmap, TASKPARMEX * parm);


}  // extern "C"

#endif