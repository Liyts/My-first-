/****** NETAPI.H ************* Tarakanova I.R.  ******* 03/07/15 ***
******* NETAPI.H ************* Shabakov D.A.    ******* 31/05/13 ***
******* NETAPI.H ************* Борзов А.Ю.      ******* 02/08/16 ***
*                                                                  *
*              Copyright (c) PANORAMA Group 1991-2014              *
*                      All Rights Reserved                         *
*                                                                  *
********************************************************************
*                                                                  *
*          УСТАРЕВШИЕ ФУНКЦИЙ ДОСТУПА К СЕТИ ОБЪЕКТОВ              *
*           НОВЫЕ ФУНКЦИИ СМ. GRAPHAPI.H, GRAPHDLG.H               *
*             ФУНКЦИИ ИМПОРТИРУЮТСЯ ИЗ OBJNET.DLL                  *
*                                                                  *
********************************************************************/

#ifndef NETAPI_H
#define NETAPI_H

#ifndef MAPTYPE_H
  #include "maptype.h"
#endif

#ifdef WIN32API
#if defined(_NETDLLEXP)
  #define _NETIMP __declspec(dllexport)
#else
  #define _NETIMP __declspec(dllimport)
#endif
#else
  #define _NETIMP
#endif

// Коды семантик для логических связей между объектами сети:
#define SEMNETRIB       32812  // Номер объекта-ребра (для узла)
#define SEMNETKNOTFIRST 32813  // Номер объекта-узла первой точки (для ребра)
#define SEMNETKNOTLAST  32814  // Номер объекта-узла последней точки (для ребра)
#define SEMNETNUMBER    32815  // Номер сети
#define SEMNETTOOBJECT  32816  // Ссылка на объект листа
#define SEMNETVDIRECT   32817  // Скорость прямая (для ребра)
#define SEMNETVUNDIRECT 32818  // Скорость обратная (для ребра)
#define SEMNETCOSTRIB   32819  // Стоимость ребра
#define SEMNETRANKRIB   32820  // Ранг ребра

typedef HANDLE HGRAPH;  // идентификатор графа

extern "C"
{
// Построение карты графа с вызовом диалога
// hmap - идентификатор открытой векторной карты
// parm - описание параметров задачи
// На карте предварительно должны быть выделены объекты для построения сети
// При успешном выполнении возвращает идентификатор пользовательской карты
// с построенной сетью
// При ошибке возвращает 0

_NETIMP HSITE WINAPI onCreateNetDlg(HMAP hmap, TASKPARMEX *parm);

// Построение карты графа с вызовом или без вызова диалога
// hmap - идентификатор открытой векторной карты
// parm - описание параметров задачи (см.maptype.h)
// namesit - имя выходного файла
// namersc - полное имя файла классификатора road25.rsc                         // 02/08/16
// flag - управление диалогом  "Построение сети" (0- не вызывать диалог, 1 - вызывать)

_NETIMP HSITE WINAPI onCreateNetDlgEx(HMAP hmap, TASKPARMEX *parm,
                              char *namesit, char *namersc, long int flag);

_NETIMP HSITE WINAPI onCreateNetDlgUn(HMAP hmap, TASKPARMEX *parm,
                              WCHAR *namesit, WCHAR *namersc, long int flag);

// Определение кратчайшего расстояния между двумя узлами сети
// hmap - идентификатор открытой векторной карты
// site - пользовательская карта с построенной сетью, т.е. на карте должны быть
// объекты узлы сети с обязательными семантиками: номер сети и ссылка на ребро
// сети, и ребра с семантиками: номер первого и последнего узлов для данного
// ребра, ссылка на объект карты и номер сети
// pointbegin - начальный узел (идентификатор объекта карты в памяти)
// pointend - конечный узел (идентификатор объекта карты в памяти)
// В функции вызывается диалог "Параметры построения минимального пути", в котором
// устанавливаются метод построения (длина или время,в последнем случае ребра
// должны иметь семантику "Скорость") и фильтр по семантикам ребер
// По окончании работы функции выдается результирующий диалог "Список объектов",
// в который записываются реальные объекты карты и протяженность пути по каждому объекту
// На пользовательской картe будут выделены ребра,которые составляют минимальный маршрут
// Число выделенных объектов определяется функцией mapTotalSeekObjectCount(seekapi.h)
// Получить идентификатор выделенного объекта можно используя функцию mapTotalSeekObject(seekapi.h)
// Возвращает: номер объекта (mapObjectKey), если объект маршрут создавался
//            - 1, если объект маршрут не создавался
//              0, при ошибке

_NETIMP long int WINAPI onSeekPathDlg(HMAP hmap, HSITE site, TASKPARMEX *parm,
                              HOBJ infobegin, HOBJ infoend);

// Определение кратчайшего расстояния между двумя узлами сети без вызова диалогов
// hmap - идентификатор открытой векторной карты
// site - пользовательская карта с построенной сетью, т.е. на карте должны быть
// объекты узлы сети с обязательными семантиками: номер сети и ссылка на ребро
// сети, и ребра с семантиками: номер первого и последнего узлов для данного
// ребра, ссылка на объект карты и номер сети
// pointbegin - начальный узел(идентификатор объекта карты в памяти)
// pointend - конечный узел(идентификатор объекта карты в памяти)
// methodseek - метод построения (0 - длина, 1- время)
// speed - средняя скорость (км/ч)(если methodseek = 1 и значения семантики
// "Скорость" не установлены)
// На пользовательской картe будут выделены ребра,которые составляют минимальный маршрут
// Число выделенных объектов определяется функцией mapTotalSeekObjectCount(seekapi.h)
// Получить идентификатор выделенного объекта можно используя функцию mapTotalSeekObject(seekapi.h)
// Возвращает: номер объекта (mapObjectKey), если объект маршрут создавался
//            - 1, если объект маршрут не создавался
//              0, при ошибке

_NETIMP long int WINAPI onSeekPath(HMAP hmap, HSITE site, TASKPARMEX *parm,
                           HOBJ infobegin, HOBJ infoend,
                           long int methodseek, double speed);

// Определение кратчайшего расстояния между двумя узлами сети без вызова диалогов
// hmap - идентификатор открытой векторной карты
// site - пользовательская карта с построенной сетью, т.е. на карте должны быть
// объекты узлы сети с обязательными семантиками: номер сети и ссылка на ребро
// сети, и ребра с семантиками: номер первого и последнего узлов для данного
// ребра, ссылка на объект карты и номер сети
// object - идентификатор объекта в памяти,
//        предварительно созданного функцией mapCreateObject()
//        или mapCreateSiteObject(),
//        в котором будет размещен результат - минимальный путь.
// pointbegin - начальный узел(идентификатор объекта карты в памяти)
// pointend - конечный узел(идентификатор объекта карты в памяти)
// methodseek - метод построения (0 - длина, 1- время)
// speed - средняя скорость (км/ч)(если methodseek = 1 и значения семантики
// "Скорость" не установлены)
// Возвращает: -1, если путь найден
//              0, при ошибке

_NETIMP long int WINAPI onSeekPathCreateObject(HMAP hmap, HSITE site,
                                       TASKPARMEX *parm, HOBJ object,
                                       HOBJ infobegin, HOBJ infoend,
                                       long int methodseek, double speed);

// Определение кратчайшего расстояния между двумя точками
// hmap - идентификатор открытой векторной карты
// site - пользовательская карта с построенной сетью, т.е. на карте должны быть
// объекты узлы сети с обязательными семантиками: номер сети и ссылка на ребро
// сети, и ребра с семантиками: номер первого и последнего узлов для данного
// ребра, ссылка на объект карты и номер сети
// info - идентификатор объекта в памяти,
//        предварительно созданного функцией mapCreateObject()
//        или mapCreateSiteObject(),
//        в котором будет размещен результат - минимальный путь
// point1 - начальная точка в метрах на местности
// point2 - конечная точка в метрах на местности
// Путь определяется от точки на ближайшем ребре к point1 до точки на ближайшем
// ребре к point2
// На картe создается условный объект - минимальный маршрут
// Возвращает: номер объекта (mapObjectKey), если объект маршрут создавался
//            - 1, если объект маршрут не создавался
//              0, при ошибке

_NETIMP long int WINAPI onSeekPathDlgByPoint(HMAP hmap, HSITE site, HOBJ info, TASKPARMEX *parm,
                                     DOUBLEPOINT *point1,DOUBLEPOINT *point2);

// Определение кратчайшего расстояния между двумя точками
// hmap - идентификатор открытой векторной карты
// site - пользовательская карта с построенной сетью, т.е. на карте должны быть
// объекты узлы сети с обязательными семантиками: номер сети и ссылка на ребро
// сети, и ребра с семантиками: номер первого и последнего узлов для данного
// ребра, ссылка на объект карты и номер сети
// info - идентификатор объекта в памяти,
//        предварительно созданного функцией mapCreateObject()
//        или mapCreateSiteObject(),
//        в котором будет размещен результат - минимальный путь
// point1 - начальная точка в метрах на местности
// point2 - конечная точка в метрах на местности
// Путь определяется от точки на ближайшем ребре к point1 до точки на ближайшем
// ребре к point2
// Возвращает: -1, если путь найден
//              0, при ошибке

_NETIMP long int WINAPI onSeekPathByPoint(HMAP hmap, HSITE site, HOBJ info, TASKPARMEX *parm,
                                  DOUBLEPOINT *point1,DOUBLEPOINT *point2);

// Определение кратчайшего расстояния между двумя точками с учетом одностороннего
// движения и исключением ребер (аварийных участков)
// hmap - идентификатор открытой векторной карты
// site - пользовательская карта с построенной сетью, т.е. на карте должны быть
// объекты узлы сети с обязательными семантиками: номер сети и ссылка на ребро
// сети, и ребра с семантиками: номер первого и последнего узлов для данного
// ребра, ссылка на объект карты и номер сети
// info - идентификатор объекта в памяти,
//        предварительно созданного функцией mapCreateObject()
//        или mapCreateSiteObject(),
//        в котором будет размещен результат - минимальный путь
// point1 - начальная точка в метрах на местности
// point2 - конечная точка в метрах на местности
// select - контекст условий поиска (должен содержать ребра, которые исключаются из поиска мин. пути)
// foneway - флаг одностороннего движения (0 - не учитывать, 1- учитывать)
// Путь определяется от точки на ближайшем ребре к point1 до точки на ближайшем
// ребре к point2
// Возвращает: -1, если путь найден
//              0, при ошибке

_NETIMP long int WINAPI onSeekPathByPointEx(HMAP hmap, HSITE site, HOBJ info, TASKPARMEX *parm,
                                    DOUBLEPOINT *point1, DOUBLEPOINT *point2,
                                    HSELECT select, long int foneway);

// Нахождение в сети ребер, расположенных на расстоянии менее заданного от
// указанного узла (построение графа удаленности)
// hmap - идентификатор открытой векторной карты
// site - пользовательская карта с построенной сетью, т.е. на карте должны быть
// объекты узлы сети с обязательными семантиками: номер сети и ссылка на ребро
// сети, и ребра с семантиками: номер первого и последнего узлов для данного
// ребра, ссылка на объект карты и номер сети
// info -  узел сети (идентификатор объекта карты в памяти)
// distance - расстояние в метрах
// На пользовательской карте будут выделены ребра, расположенные  на расстоянии,
// менее distance от info
// Число выделенных объектов определяется функцией mapTotalSeekObjectCount(seekapi.h)
// Получить идентификатор объекта можно используя функцию mapTotalSeekObject(seekapi.h)
// При ошибке возвращает 0

_NETIMP long int WINAPI onDistFromKnot(HMAP hmap, HSITE site, TASKPARMEX *parm,
                               HOBJ info, double distance);

// Получить ближайший узел сети к указанной точке
// hmap - идентификатор открытой векторной карты
// site - пользовательская карта с построенной сетью
// info - идентификатор объекта карты в памяти
// point - координаты точки в метрах  в системе карты
// Пример использования:
//  - создаем объект
//    HOBJ hobj = mapCreateSiteObject(hmap,site,IDDOUBLE2,0);
//  - находим ближайший узел к точке point и записываем в hobj
//    long int ret = onGetNodeByPoint(hmap,site,hobj, point);
//  - вызываем функцию работы с сетью
//    if (ret)
//        onDistFromKnot(hmap,site,parm,hobj,20);
// При ошибке возвращает 0

_NETIMP long int WINAPI onGetNodeByPoint(HMAP hmap, HSITE site,
                                 HOBJ info, DOUBLEPOINT *point);

// Получить ближайший линейный объект (ребро) к указанной точке
// hmap - идентификатор открытой векторной карты
// site - пользовательская карта с построенной сетью
// info - идентификатор объекта карты в памяти
// point - координаты точки в метрах  в системе карты
// При ошибке возвращает 0

_NETIMP long int WINAPI onGetRibByPoint(HMAP hmap, HSITE site,
                                HOBJ info, DOUBLEPOINT *point);

// Вычисление минимального пути между точками (узлами сети)
// hmap - идентификатор открытой векторной карты
// site - пользовательская карта с построенной сетью
// parm - описание параметров задачи (см.maptype.h)
// array - адрес массива координат опорных точек,
//         размер массива равен count
// count - количество точек для построения минимального пути
// Расчеты производятся по ближайшим к точкам узлам сети
// В функции вызывается диалог "Параметры построения минимального пути", в котором
// устанавливаются метод построения (длина или время,в последнем случае ребра
// должны иметь семантику "Скорость") и фильтр по семантикам ребер
// По окончании работы функции выдается результирующий диалог "Порядок обхода точек",
// в который записываются номера точек в том порядке, в котором путь прохождения по ним минимален,
// протяженность маршрута между соседней парой точек, общая длина пути.
// При ошибке возвращает 0

_NETIMP long int WINAPI onMinimalPath(HMAP hmap, HSITE site, TASKPARMEX *parm,
                              DOUBLEPOINT *arraypoint, long int count);

// Вычисление минимального пути между точками (узлами сети)
// hmap - идентификатор открытой векторной карты
// site - пользовательская карта с построенной сетью
// parm - описание параметров задачи (см.maptype.h)
// arraypoint - адрес массива координат (в метрах на местности) опорных точек,
//              размер массива равен count
// arraynumber - адрес массива с номерами точек (для результатов),
//               размер массива равен count
// count - количество точек для построения минимального пути
// flagoneway - флаг одностороннего движения (0 - не учитывать, 1 - учитывать)
// flagreturn - флаг возврата в первую точку (0 - не возвращаться, 1 - возвращаться)
// flagcalc - метод расчета (0 - по длине, 1- по времени)
// Расчеты производятся по ближайшим к точкам узлам сети
// В массив arraynumber будут записаны номера точек, которые определяют порядок обхода
// Возвращает общую длину пути
// При ошибке возвращает 0

_NETIMP double WINAPI onMinimalPathEx(HMAP hmap, HSITE site, TASKPARMEX *parm,
                                      DOUBLEPOINT *arraypoint, long int *arraynumber,
                                      long int count, long int flagoneway,
                                      long int flagreturn, long int flagcalc);

// Редактирование сети - удаление узлов
// hmap - идентификатор открытой векторной карты
// site - пользовательская карта с построенной сетью
// info - идентификатор объекта, который нужно удалить
// Узел для удаления должен иметь ссылки на четыре ребра
// Если у противолежащих ребер совпадает семантика, то узел удаляется,если нет -
// удаляются семантики  и для каждой пары ребер создается свой узел
// При ошибке возвращает 0

_NETIMP long int WINAPI onEditDeleteNode(HMAP hmap, HSITE site,TASKPARMEX *parm,
                                         HOBJ info);

// Редактирование сети - добавление узлов
// hmap - идентификатор открытой векторной карты
// site - пользовательская карта с построенной сетью
// info1 и info2 - идентификаторы объектов, на пересечении которых нужно добавить узел
// Функция обратная к  onEditDeleteNode(...)
// Добавляет удаленные узлы и согласовывает семантики
// При ошибке возвращает 0

_NETIMP long int WINAPI onEditAddNode(HMAP hmap, HSITE site,TASKPARMEX *parm,
                                      HOBJ info1, HOBJ info2);

// Редактирование сети - распараллеливание дорог
// hmap - идентификатор открытой векторной карты
// site - пользовательская карта с построенной сетью
// Функция добавляет в сеть параллельные участки на перекрестках дорог
// info - идентификатор объекта(узла на перекрестке)
// Узел должен иметь ссылки на четыре ребра
// Функция создает дополнительные узлы сети и ребра сети односторонние
// При ошибке возвращает 0

_NETIMP long int WINAPI onEditRoad(HMAP hmap, HSITE site,TASKPARMEX *parm,
                           HOBJ info);

// Редактирование сети - создание съездов и разворотов
// hmap - идентификатор открытой векторной карты
// site - пользовательская карта с построенной сетью
// info1 и info2 - идентификаторы объектов (ребер),должны иметь общий узел и быть односторонними
// В качестве info1 и info2 рекомендуется использовать результаты функции onEditRoad(...)
// Создает объекты - ребра в виде дуг и удаляет общий узел
// При ошибке возвращает 0
_NETIMP long int WINAPI onEditCreateArc(HMAP hmap, HSITE site,TASKPARMEX *parm,
                                HOBJ info1,HOBJ info2);

/*********************************************************
*                                                        *
*                  ФУНКЦИИ HGRAPH                        *
*                                                        *
*********************************************************/

// Открытие списка графов
// hmap - идентификатор открытой векторной карты
// site - пользовательская карта с сетью
// Идентификатор пользовательской карты с сетью  можно получить,
// используя функцию onGetGraphSiteIdent(...)
// При успешном выполнении возвращает идентификатор графа сети
// При ошибке возвращает 0

_NETIMP HGRAPH WINAPI onOpenGraphEx(HMAP hmap, HSITE site);

// Закрыть список графов
// hgraph - идентификатор графа сети

_NETIMP long int WINAPI onCloseGraph(HGRAPH hgraph);

// Определить sit с сетью
// hmap - идентификатор открытой векторной карты
// При успешном выполнении возвращает идентификатор пользовательской
// карты с графом сети (если карт с сетью несколько, возвращается идентификатор
// первой карты с сетью)
// При ошибке возвращает 0

_NETIMP HSITE WINAPI onGetGraphSiteIdent(HMAP hmap);


_NETIMP long int WINAPI onSeekPathDlgGraph(HMAP hmap, HGRAPH hgraph, TASKPARMEX *parm,
                                   HOBJ infobegin, HOBJ infoend);

// Определение кратчайшего расстояния между двумя узлами сети без вызова диалогов
// hmap - идентификатор открытой векторной карты
// hgraph - идентификатор графа сети, предварительно должен быть открыт функцией
// onOpenGraph(...)
// pointbegin - начальный узел(идентификатор объекта карты в памяти)
// pointend - конечный узел(идентификатор объекта карты в памяти)
// methodseek - метод построения (0 - длина, 1- время)
// speed - средняя скорость (км/ч)(если methodseek = 1 и значения семантики
// "Скорость" не установлены)
// На пользовательской картe будут выделены ребра,которые составляют минимальный маршрут
// Число выделенных объектов определяется функцией mapTotalSeekObjectCount(seekapi.h)
// Получить идентификатор выделенного объекта можно используя функцию mapTotalSeekObject(seekapi.h)
// Возвращает: номер объекта (mapObjectKey), если объект маршрут создавался
//            - 1, если объект маршрут не создавался
//              0, при ошибке

_NETIMP long int WINAPI onSeekPathGraph(HMAP hmap, HGRAPH hgraph, TASKPARMEX *parm,
                                HOBJ infobegin, HOBJ infoend,
                                long int methodseek, double speed);

// Определение кратчайшего расстояния между двумя узлами сети без вызова диалогов
// hmap - идентификатор открытой векторной карты
// hgraph - идентификатор графа сети, предварительно должен быть открыт функцией
// onOpenGraph(...)
// object - идентификатор объекта в памяти,
//        предварительно созданного функцией mapCreateObject()
//        или mapCreateSiteObject(),
//        в котором будет размещен результат - минимальный путь.
// infobegin - начальный узел(идентификатор объекта карты в памяти)
// infoend - конечный узел(идентификатор объекта карты в памяти)
// select - контекст условий поиска, предварительно созданный функцией
// mapCreateSiteSelectContext(...), для размещения результатов (в select записываются
// дуги, которые составляют минимальный путь)
// methodseek - метод построения (0 - длина, 1- время)
// speed - средняя скорость (км/ч)(если methodseek = 1 и значения семантики
// "Скорость" не установлены)
// При ошибке возвращает 0

_NETIMP long int WINAPI onSeekPathGraphSelect(HMAP hmap, HGRAPH hgraph, HOBJ object,
                                      HOBJ infobegin, HOBJ infoend, HSELECT select,
                                      long int methodseek, double speed);

// Определение кратчайшего расстояния между двумя узлами сети без вызова диалогов
// hmap - идентификатор открытой векторной карты
// hgraph - идентификатор графа сети, предварительно должен быть открыт функцией
// onOpenGraph(...)
// object - идентификатор объекта в памяти,
//        предварительно созданного функцией mapCreateObject()
//        или mapCreateSiteObject(),
//        в котором будет размещен результат - минимальный путь.
// pointbegin - начальный узел(идентификатор объекта карты в памяти)
// pointend - конечный узел(идентификатор объекта карты в памяти)
// methodseek - метод построения (0 - длина, 1- время)
// speed - средняя скорость (км/ч)(если methodseek = 1 и значения семантики
// "Скорость" не установлены)
// Возвращает: -1, если путь найден
//              0, при ошибке

_NETIMP long int WINAPI onSeekPathCreateObjectGraph(HMAP hmap, HGRAPH hgraph, TASKPARMEX * parm,
                                            HOBJ object, HOBJ infobegin, HOBJ infoend,
                                            long int methodseek, double speed);

// Определение кратчайшего расстояния между двумя точками
// hmap - идентификатор открытой векторной карты
// hgraph - идентификатор графа сети, предварительно должен быть открыт функцией
// onOpenGraph(...)
// info - идентификатор объекта в памяти,
//        предварительно созданного функцией mapCreateObject()
//        или mapCreateSiteObject(),
//        в котором будет размещен результат - минимальный путь
// point1 - начальная точка в метрах на местности
// point2 - конечная точка в метрах на местности
// Путь определяется от точки на ближайшем ребре к point1 до точки на ближайшем
// ребре к point2
// На картe создается условный объект - минимальный маршрут
// Возвращает: номер объекта (mapObjectKey), если объект маршрут создавался
//            - 1, если объект маршрут не создавался
//              0, при ошибке

_NETIMP long int WINAPI onSeekPathDlgByPointGraph(HMAP hmap, HGRAPH hgraph, HOBJ info, TASKPARMEX *parm,
                                          DOUBLEPOINT *point1, DOUBLEPOINT *point2);

// Определение кратчайшего расстояния между двумя точками
// hmap - идентификатор открытой векторной карты
// hgraph - идентификатор графа сети, предварительно должен быть открыт функцией
// onOpenGraph(...)
// info - идентификатор объекта в памяти,
//        предварительно созданного функцией mapCreateObject()
//        или mapCreateSiteObject(),
//        в котором будет размещен результат - минимальный путь
// point1 - начальная точка в метрах на местности
// point2 - конечная точка в метрах на местности
// Путь определяется от точки на ближайшем ребре к point1 до точки на ближайшем
// ребре к point2
// Возвращает: -1, если путь найден
//              0, при ошибке

_NETIMP long int WINAPI onSeekPathByPointGraph(HMAP hmap, HGRAPH hgraph, HOBJ info, TASKPARMEX * parm,
                                       DOUBLEPOINT *point1, DOUBLEPOINT *point2);

// Определение кратчайшего расстояния между двумя точками
// hmap - идентификатор открытой векторной карты
// hgraph - идентификатор графа сети, предварительно должен быть открыт функцией
// onOpenGraph(...)
// info - идентификатор объекта в памяти,
//        предварительно созданного функцией mapCreateObject()
//        или mapCreateSiteObject(),
//        в котором будет размещен результат - минимальный путь
// point1 - начальная точка в метрах на местности
// point2 - конечная точка в метрах на местности
// Путь определяется от точки на ближайшем ребре к point1 до точки на ближайшем
// ребре к point2
// При ошибке возвращает 0

_NETIMP long int WINAPI onSeekPathByPointGraphEx(HMAP hmap,HGRAPH hgraph, HOBJ info,
                                         DOUBLEPOINT *point1, DOUBLEPOINT *point2);

// Определение кратчайшего расстояния между двумя точками с учетом одностороннего
// движения и исключением ребер (аварийных участков)
// hmap - идентификатор открытой векторной карты
// hgraph - идентификатор графа сети, предварительно должен быть открыт функцией
// onOpenGraph(...)
// info - идентификатор объекта в памяти,
//        предварительно созданного функцией mapCreateObject()
//        или mapCreateSiteObject(),
//        в котором будет размещен результат - минимальный путь
// point1 - начальная точка в метрах на местности
// point2 - конечная точка в метрах на местности
// select - контекст условий поиска (должен содержать ребра, которые исключаются из поиска мин. пути)
// одностороннее движение учитывается всегда
// Путь определяется от точки на ближайшем ребре к point1 до точки на ближайшем
// ребре к point2
// Возвращает: -1, если путь найден
//              0, при ошибке

_NETIMP long int WINAPI onSeekPathByPointExGraph(HMAP hmap, HGRAPH hgraph, HOBJ info,
                                         TASKPARMEX *parm, DOUBLEPOINT *point1,
                                         DOUBLEPOINT *point2, HSELECT select);

// Получить количество дуг маршрута
// hmap - идентификатор открытой векторной карты
// hgraph - идентификатор графа сети, предварительно должен быть открыт функцией
// onOpenGraph(...)
// infobegin - начальный узел(идентификатор объекта карты в памяти)
// infoend - конечный узел(идентификатор объекта карты в памяти)
// Возвращает: количество дуг маршрута от infobegin до infoend

_NETIMP long int WINAPI onGetCountRib(HMAP hmap, HGRAPH hgraph,
                                      HOBJ infobegin, HOBJ infoend);

// Получить массив номеров дуг маршрута от infobegin до infoend
// hmap - идентификатор открытой векторной карты
// hgraph - идентификатор графа сети, предварительно должен быть открыт функцией
// onOpenGraph(...)
// infobegin - начальный узел(идентификатор объекта карты в памяти)
// infoend - конечный узел(идентификатор объекта карты в памяти)
// arrayrib - адрес массива для номеров дуг,  размер массива равен count
// count - количество дуг, д.б. получены функцией onGetCountRib(...)
// При ошибке возвращает 0

_NETIMP long int WINAPI onGetArrayRib(HMAP hmap, HGRAPH hgraph,
                                      HOBJ infobegin, HOBJ infoend,
                                      long int *arrayrib, long int count);

// Нахождение в сети ребер, расположенных на расстоянии менее заданного от
// указанного узла (построение графа удаленности)
// hmap - идентификатор открытой векторной карты
// hgraph - идентификатор графа сети, предварительно должен быть открыт функцией
// onOpenGraph(...)
// info -  узел сети (идентификатор объекта карты в памяти)
// distance - расстояние в метрах
// На пользовательской карте будут выделены ребра, расположенные  на расстоянии,
// менее distance от info
// Число выделенных объектов определяется функцией mapTotalSeekObjectCount(seekapi.h)
// Получить идентификатор объекта можно используя функцию mapTotalSeekObject(seekapi.h)
// При ошибке возвращает 0

_NETIMP long int WINAPI onDistFromKnotGraph(HMAP hmap, HGRAPH hgraph, TASKPARMEX *parm,
                                    HOBJ info, double distance);

// Нахождение в сети ребер, расположенных на расстоянии менее заданного от
// указанного узла (построение графа удаленности)
// hmap - идентификатор открытой векторной карты
// hgraph - идентификатор графа сети, предварительно должен быть открыт функцией
// onOpenGraph(...)
// select - контекст условий поиска, предварительно созданный функцией
// mapCreateSiteSelectContext(...), для размещения результатов (в select записываются
// дуги, которые составляют граф удаленности)
// info -  узел сети (идентификатор объекта карты в памяти)
// distance - расстояние в метрах
// При ошибке возвращает 0

_NETIMP long int WINAPI onDistFromKnotGraphEx(HMAP hmap, HGRAPH hgraph, HSELECT select,
                                      HOBJ info, double distance);

// Вычисление минимального пути между точками (узлами сети)
// hmap - идентификатор открытой векторной карты
// hgraph - идентификатор графа сети, предварительно должен быть открыт функцией
// onOpenGraph(...)
// parm - описание параметров задачи (см.maptype.h)
// array - адрес массива координат опорных точек,
//         размер массива равен count
// count - количество точек для построения минимального пути
// Расчеты производятся по ближайшим к точкам узлам сети
// В функции вызывается диалог "Параметры построения минимального пути", в котором
// устанавливаются метод построения (длина или время,в последнем случае ребра
// должны иметь семантику "Скорость") и фильтр по семантикам ребер
// По окончании работы функции выдается результирующий диалог "Порядок обхода точек",
// в который записываются номера точек в том порядке, в котором путь прохождения по ним минимален,
// протяженность маршрута между соседней парой точек, общая длина пути.
// При ошибке возвращает 0

_NETIMP long int WINAPI onMinimalPathGraph(HMAP hmap, HGRAPH hgraph, TASKPARMEX *parm,
                                   DOUBLEPOINT *arraypoint, long int count);

// Вычисление минимального пути между точками (результаты отображаются на tempsite)
// hmap - идентификатор открытой векторной карты
// hgraph - идентификатор графа сети, предварительно должен быть открыт функцией
// onOpenGraph(...)
// parm - описание параметров задачи (см.maptype.h)
// tempsite - НЕ ИСПОЛЬЗУЕТСЯ (МОЖЕТ БЫТЬ РАВЕН 0)
// array - адрес массива координат (в метрах на местности) опорных точек,
//         размер массива равен count
// count - количество точек для построения минимального пути
// Расчеты производятся по ближайшим к точкам узлам сети
// В функции вызывается диалог "Параметры построения минимального пути", в котором
// устанавливаются метод построения (длина или время,в последнем случае ребра
// должны иметь семантику "Скорость") и фильтр по семантикам ребер
// По окончании работы функции выдается результирующий диалог "Порядок обхода точек",
// в который записываются номера точек в том порядке, в котором путь прохождения по ним минимален,
// протяженность маршрута между соседней парой точек, общая длина пути.
// При ошибке возвращает 0

_NETIMP long int WINAPI onMinimalPathSiteGraph(HMAP hmap,HGRAPH hgraph, TASKPARMEX *parm,
                                       HSITE tempsite, DOUBLEPOINT *arraypoint,
                                       long int count);

// Вычисление минимального пути между точками (узлами сети)
// hmap - идентификатор открытой векторной карты
// hgraph - идентификатор графа сети, предварительно должен быть открыт функцией
// onOpenGraph(...)
// parm - описание параметров задачи (см.maptype.h)
// arraypoint - адрес массива координат (в метрах)  опорных точек,
//              размер массива равен count
// arraynumber - адрес массива с номерами точек (для результатов),
//               размер массива равен count
// count - количество точек для построения минимального пути
// одностороннее движение учитывается всегда
// flagreturn - флаг возврата в первую точку (0 - не возвращаться, 1 - возвращаться)
// flagcalc - метод расчета (0 - по длине, 1- по времени)
// Расчеты производятся по ближайшим к точкам узлам сети
// В массив arraynumber будут записаны номера точек, которые определяют порядок обхода
// Возвращает общую длину пути
// При ошибке возвращает 0

_NETIMP double WINAPI onMinimalPathExGraph(HMAP hmap, HGRAPH hgraph, TASKPARMEX *parm,
                                           DOUBLEPOINT *arraypoint, long int *arraynumber,
                                           long int count, long int flagreturn, long int flagcalc);

// Вычисление минимального пути между точками (узлами сети)
// hmap - идентификатор открытой векторной карты
// hgraph - идентификатор графа сети, предварительно должен быть открыт функцией
// onOpenGraphEx(...)
// info - идентификатор объекта в памяти,
//        предварительно созданного функцией mapCreateObject()
//        или mapCreateSiteObject(),
//        в котором будет размещен результат - минимальный путь
// arraypoint - адрес массива координат (в метрах)  опорных точек,
//              размер массива равен count
// arraynumber - адрес массива с номерами точек (для результатов),
//               размер массива равен count
// count - количество точек для построения минимального пути
// одностороннее движение учитывается всегда
// flagreturn - флаг возврата в первую точку (0 - не возвращаться, 1 - возвращаться)
// flagcalc - метод расчета (0 - по длине, 1- по времени)
// Расчеты производятся по ближайшим к точкам узлам сети
// В массив arraynumber будут записаны номера точек, которые определяют порядок обхода
// При ошибке возвращает 0

_NETIMP long int WINAPI onMinimalPathExGraphEx(HMAP hmap, HGRAPH hgraph, HOBJ info,
                                     DOUBLEPOINT *arraypoint, long int *arraynumber,
                                     long int count, long int flagreturn, long int flagcalc);

} // extern "C"


#endif  // NETAPI_H
